;;; ellit-org.el --- Emacs Lisp Literate programming tool  -*- lexical-binding:t -*-

;; Copyright (C) 2020 by Zajcev Evgeny.

;; Author: Zajcev Evgeny <zevlg@yandex.ru>
;; Created: Wed Jan 22 10:35:15 2020
;; Keywords: convenience
;; Package-Requires: ((emacs "25.1"))
;; URL: https://github.com/zevlg/ellit-org.el
;; Version: 0.1
(defconst ellit-org-version "0.1")

;; ellit-org is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; ellit-org is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with ellit-org.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; #+TITLE: ellit-org
;; #+STARTUP: showall
;;
;; Emacs Lisp Literate programming tool
;;
;; #+BEGIN_QUOTE
;; This file is automatically generated from =>>>ELFILE<<<= by
;; ~ellit-org.el v>>>EVAL ellit-org-version<<<~ tool.
;; Do not edit manually.
;; #+END_QUOTE
;;
;; Generate documentation for Emacs Lisp package by extracting text
;; from comments of =.el= files and organizing them into single =.org=
;; file.
;;
;; Idea is similiar to https://github.com/tumashu/el2org
;;
;; However =ellit-org= includes simple templating system, which is nice
;; to have thing in documentation generator tool.
;;
;; * Why?
;;
;; Separate files for code and documentanion is hard to get in sync.
;; Once changing something in source code files, you might change
;; comments as well and forget about documentation.
;;
;; Also many things, useful for documentation, might be automatically
;; extracted from source code.  Such as:
;; - Keybindings
;; - Customizable options
;; - Docstrings for commands
;; - etc
;;
;; * Using ellit-org in your project
;;
;; Sample Makefile to generate user manual for the project:
;;
;; #+BEGIN_SRC Makefile
;; EMACS=emacs -Q
;;
;; manual.org: srcfile.el <list-of-other-files-used-to-generate-manual>
;;      $(EMACS) -batch -f package-initialize -l ellit-org \
;;                  --eval '(ellit-org-file "srcfile.el" "manual.org")'
;; #+END_SRC
;;
;; * Commenting .el files
;;
;; - Use double-semicolon comments, otherwise processing won't start
;; - Processing starts when Org mode's property, heading or list is seen
;; - Processing stops on any non-commentary string
;;
;; Here is the example:
;; #+begin_src emacs-lisp
;;   ;; * Heading1                        <--- processing starts here
;;   ;; This line is included into output
;;   ;;
;;   ;; This line also included into output
;;                                        <--- processing stops here
;;   ;; This line is *not* included into output
;;
;;   ;; - However this line, is included  <--- processing starts here
;;   ;;
;;   ;;    Since new processing is started, and it will stop only on
;;   ;;    non-commentary line below
;;                                        <--- processing stops here
;;   ;; This line is *not* included
;; #+end_src


;;; Code:
(defvar ellit-org-start-regexp
  (rx (and (1+ space)
           (or "#+"
               (and (or (1+ "*") "+" "-"
                        (and (1+ digit) (or "." ")")))
                    space))))
  "Regexp matching start of the text to extract.")

;; * Templating

;; ellit-org includes very simple templating system to automatically
;; extract useful bits from source code or from Emacs runtime.

;; Templates substitution is done *after* processing comments, so make
;; sure your templates are in processed part of the comments.

;; Templates syntax:
;; #+begin_example
;; >>>TEMPLATE_NAME ARGUMENTS<<<
;; #+end_example
;; ~ARGUMENTS~ are optional string supplied to function which does
;; processing for ~TEMPLATE_NAME~.

;; Supported templates:
(defvar ellit-org-template-alist
  '(
    ;; - ELLIT <file> ::
    ;;   >>>FUNDOC1 ellit-org-template-ellit<<<
    ("ELLIT" . ellit-org-template-ellit)

    ;; - ELFILE ::
    ;;   >>>FUNDOC1 ellit-org-template-elfile<<<
    ("ELFILE" . ellit-org-template-elfile)

    ;; - EVAL <form> ::
    ;;   >>>FUNDOC1 ellit-org-template-eval<<<
    ("EVAL" . ellit-org-template-eval)

    ;; - KEY-V1 [<keymap>:]<command> ::
    ;;   >>>FUNDOC1 ellit-org-template-key1<<<
    ("KEY-V1" . ellit-org-template-key1)

    ;; - KEY-V2 [<keymap>:]<command> ::
    ;;   >>>FUNDOC1 ellit-org-template-key2<<<
    ("KEY-V2" . ellit-org-template-key2)

    ;; - VARDOC1 <variable> ::
    ;;   >>>FUNDOC1 ellit-org-template-vardoc1<<<
    ("VARDOC1" . ellit-org-template-vardoc1)

    ;; - VARDOC <variable> ::
    ;;   >>>FUNDOC1 ellit-org-template-vardoc<<<
    ("VARDOC" . ellit-org-template-vardoc)

    ;; - FUNDOC1 <function> ::
    ;;   >>>FUNDOC1 ellit-org-template-fundoc1<<<
    ("FUNDOC1" . ellit-org-template-fundoc1)

    ;; - FUNDOC <function> ::
    ;;   >>>FUNDOC1 ellit-org-template-fundoc<<<
    ("FUNDOC" . ellit-org-template-fundoc))
  "Alist of available templates.
Each element in form:
  (TEMPLATE-NAME . TEMPLATE-FUNC)
TEMPLATE-FUNC is called with single string(or nil) argument.")

(defvar ellit-org-directory nil
  "Bind this var to the current ellit-doc directory.
Used to lookup files in >>>ELLIT<<< template chunks.")

(defvar ellit-org-elfile nil
  "Filename of the currently processing file.")

(defun ellit-org-apply-template (name &optional arg)
  "Return value for the template chunk with NAME.
Optional string ARG could be given.
Return newtext or nil."
  (when-let ((template (assoc name ellit-org-template-alist)))
    (funcall (cdr template) arg)))

(defun ellit-org-apply-all-templates ()
  "Replace all template chunks in current buffer with their values."
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward ">>>\\([a-zA-Z0-9-]+\\)\s*\\([^<]*\\)<<<" nil t)
      (let* ((beg (match-beginning 0))
             (end (match-end 0))
             (template-name (match-string 1))
             (template-arg (match-string 2))
             (new-text (ellit-org-apply-template template-name template-arg)))
        (when new-text
          (replace-region-contents beg end (lambda () new-text)))))))

(defun ellit-org-extract-comments ()
  "Extract comments from current buffer."
  (save-excursion
    (goto-char (point-min))
    (let ((comment-start-regexp (rx (and (0+ space) ";;" (or space eol))))
          cpont)
      (while (progn (setq cpont (point))
                    (re-search-forward ellit-org-start-regexp nil 'no-error))
        (beginning-of-line)
        (delete-region cpont (point))

        ;; Scan line by line
        (while (looking-at comment-start-regexp)
          (let ((del-point (match-end 0))
                (eol-point (point-at-eol)))
            ;; DO NOT strip "\n"
            (when (> del-point eol-point)
              (setq del-point eol-point))
            (delete-region (point) del-point))

          (forward-line 1)
          (beginning-of-line))
        (delete-region (point-at-bol) (point-at-eol)))
      (delete-region cpont (point-max)))))

(defun ellit-org-file (el-file &optional output-org-file)
  "Extract documentation from EL-FILE.
Write to OUTPUT-ORG-FILE, or return as string."
  (let* ((ellit-org-elfile (expand-file-name el-file ellit-org-directory))
         (ellit-org-directory (file-name-directory ellit-org-elfile)))
    (with-temp-buffer
      (insert-file-contents ellit-org-elfile)
      (ellit-org-extract-comments)
      (ellit-org-apply-all-templates)
      (if output-org-file
          (write-region (point-min) (point-max) output-org-file
                        nil 'quiet)
        (buffer-string)))
    ))


(defun ellit-org-template-ellit (file)
  "Insert results of the FILE processing."
  (ellit-org-file file))

(defun ellit-org-template-elfile (_ignored)
  "Insert currently processing filename."
  (file-name-nondirectory ellit-org-elfile))

(defun ellit-org-template-eval (form)
  "Insert result of the FORM evaluation."
  (eval (read form)))

(defun ellit-org-template-key1 (arg)
  "Insert keybinding for the command. NOTYET DONE
ARG is either form:
  1) \"<command>\"  - lookup for <command> in `global-map'
  2) \"<keymap>:<command>\" - lookup for <command> in <keymap>
"
  ;;; Resemble magit manual, i.e.
  ;;; - Key: C-c 1, C-c 2, ~command-fun~
  ;;;
  ;;;      Documentary for the <command-fun>.
  )

(defun ellit-org-template-key2 (arg)
  "Insert keybinding for the command. NOTYET DONE"
  ;;; Resemble org manual, i.e.
  ;;; - {{{kbd(C-c 1)}}}, {{{kbd(C-c 2)}}} (~command-fun~) ::
  ;;;
  ;;;      #+kindex: C-c C-f
  ;;;      #+findex: command-fun
  ;;;      Documentary for the <command-fun>.
  )

(defun ellit-org--vardoc (varname &optional first-line-p)
  "Return docstring for the variable named by VARNAME.
If FIRST-LINE-P is non-nil, then return only first line of the docstring."
  (let* ((varsym (intern varname))
         (vardoc (documentation-property varsym 'variable-documentation)))
    (when vardoc
      (if first-line-p
          (car (split-string vardoc "\n"))
        vardoc))))

(defun ellit-org-template-vardoc1 (variable)
  "Insert first line from docstring for the VARIABLE."
  (ellit-org--vardoc variable 'first-line))

(defun ellit-org-template-vardoc (variable)
  "Insert full docstring for the VARIABLE."
  (ellit-org--vardoc variable))

(defun ellit-org--fundoc (funname &optional first-line-p)
  "Return docstring for the function named by FUNNAME.
If FIRST-LINE-P is non-nil, then return only first line of the docstring."
  (let* ((funsym (intern funname))
         (fundoc (documentation funsym)))
    (when fundoc
      (if first-line-p
          (car (split-string fundoc "\n"))
        fundoc))))

(defun ellit-org-template-fundoc1 (function)
  "Insert first line from docstring for the FUNCTION."
  (ellit-org--fundoc function 'first-line))

(defun ellit-org-template-fundoc (function)
  "Insert full docstring for the FUNCTION."
  (ellit-org--fundoc function))

(provide 'ellit-org)

;;; ellit-org.el ends here
